# Implementation Plan: E2E Test Isolation & Playground API Key Management

## Overview

This plan addresses two critical improvements for AgentHub's Playground:

1. **E2E Test MCP Server Duplication Issue**: Tests fail in full suite due to incomplete state cleanup
2. **Playground API Key Management**: Enable users to input API keys directly in Playground UI (DEV_MODE only)

### Constraints
- **Hexagonal Architecture**: Domain Layer must remain pure Python
- **TDD Required**: Red-Green-Refactor for all implementations
- **DEV_MODE Only**: API key feature restricted to development mode
- **Security**: No API key persistence, thread-safe operations

---

## Solution 1: Enhanced `/test/reset-data` API (MCP Duplication Fix)

### Problem Analysis

**Root Cause**: URL-based duplicate checking in `RegistryService.register_endpoint()` (lines 87-91) combined with incomplete cache invalidation in `/test/reset-data` API.

**Current Behavior**:
```
Test 1: Registers "test-server" at http://localhost:9000/mcp ✅
clean_state: Calls /test/reset-data (deletes from storage but NOT from cache) ⚠️
Test 2: Attempts to register same URL → DuplicateEndpointError ❌
```

**Investigation Results** (Explore agent ab622c9):
- MCP duplicate check: URL-based (name ignored)
- Storage: JSON file (`endpoints.json`)
- Cache: `DynamicToolset._tool_cache` and `._mcp_toolsets` NOT cleared
- Backend server: module-scoped (single process for all tests)

### Recommended Solution: Option B (Cache Invalidation)

**Complexity**: Medium | **Time**: 2-3 hours

#### Implementation Phases

**Phase 1: Backend Fixes (TDD)**

**Step 1.1**: Red - Add test for cache invalidation
```python
# tests/integration/adapters/test_test_utils.py (NEW FILE)
class TestResetDataCacheInvalidation:
    async def test_reset_data_clears_mcp_cache(self, client_dev_mode, registry_service):
        """Red: reset-data must invalidate DynamicToolset cache"""
        await registry_service.register_endpoint(url="http://localhost:9000/mcp", name="test-server")
        response = client_dev_mode.post("/test/reset-data")

        toolset = registry_service._toolset
        assert len(toolset._tool_cache) == 0
        assert len(toolset._mcp_toolsets) == 0
```

**Step 1.2**: Green - Implement cache invalidation
```python
# src/adapters/inbound/http/routes/test_utils.py
@router.post("/reset-data")
@inject
async def reset_test_data(
    toolset=Depends(Provide[Container.toolset]),  # NEW: Inject toolset
):
    # ... existing MCP/A2A cleanup ...

    # NEW: Invalidate toolset cache
    if hasattr(toolset, 'invalidate_cache'):
        toolset.invalidate_cache()
    if hasattr(toolset, '_mcp_toolsets'):
        toolset._mcp_toolsets.clear()
```

**Step 1.3**: Refactor - Add verification
```python
# Verify clean state
endpoints_remaining = await registry_service.list_endpoints()
if endpoints_remaining:
    errors.append(f"Cleanup incomplete: {len(endpoints_remaining)} remain")
```

**Phase 2: Test Improvements**

**Step 2.1**: Add explicit cleanup in E2E tests
```python
# tests/e2e/test_playground.py
class TestPlaygroundMcpManagement:
    def test_mcp_server_registration_flow(self, playground_page):
        # ... existing test ...
        playground_page.click("[data-testid='mcp-unregister-btn-test-server']")
```

#### Critical Files
1. `src/adapters/inbound/http/routes/test_utils.py` (Lines 24-111) - Add cache invalidation
2. `src/adapters/outbound/adk/dynamic_toolset.py` (Lines 203-216) - Verify `invalidate_cache()` clears all
3. `tests/e2e/test_playground.py` (Lines 366-416) - Add explicit cleanup
4. `tests/integration/adapters/test_test_utils.py` (NEW) - Integration test
5. `src/config/container.py` - Ensure toolset is injectable

#### Expected Outcome
- Individual tests: PASS ✅
- Combined tests: PASS ✅ (was failing before)
- No performance penalty (backend stays running)

---

## Solution 2: Playground API Key Management (DEV_MODE Feature)

### Problem Analysis

**Current State**: Backend uses environment variables (.env) → `Settings` → `os.environ` → LiteLLM

**User Request**: Playground should allow users to input API keys directly in UI (DEV_MODE only)

**Investigation Results** (Explore agent a4a21dd):
- API key flow: `.env` → pydantic Settings → `os.environ` (app startup)
- LiteLLM reads from `os.environ` at runtime
- Chat API: No `api_keys` field in `ChatRequest`
- DEV_MODE: Already validated in 3 locations (settings.py, app.py, security.py)

### Recommended Solution: Option D (Request-Scoped API Key Injection)

**Complexity**: Medium | **Time**: 3-4 hours

**Key Discovery** (Plan agent ad72be7):
- ✅ LiteLLM supports `api_key` parameter in `LiteLlm()` constructor ([LiteLLM Docs](https://docs.litellm.ai/docs/set_keys))
- ✅ Direct parameter bypasses `os.environ` (thread-safe!)
- ❌ `os.environ` modification is NOT thread-safe ([Python Issue #39375](https://bugs.python.org/issue39375))

**Architecture**:
```
Playground UI (API Key Input)
    ↓
POST /api/chat/stream {message, api_keys: {openai: "sk-..."}}
    ↓
ChatRequest.to_api_key_set() → ApiKeySet entity
    ↓
OrchestratorAdapter._rebuild_agent()
    ↓
LiteLlm(model="openai/gpt-4o-mini", api_key="sk-...")
    ↓
LiteLLM uses api_key parameter (NOT os.environ)
```

#### Implementation Phases

**Phase 1: Domain Layer (API Key Entity)**

**Step 1.1**: Create `ApiKeySet` value object
```python
# src/domain/entities/api_key_set.py (NEW FILE)
from dataclasses import dataclass

@dataclass(frozen=True)
class ApiKeySet:
    """API Key collection (DEV_MODE only)"""
    openai: str | None = None
    anthropic: str | None = None
    google: str | None = None

    def get_key_for_provider(self, provider: str) -> str | None:
        """Extract key for provider (e.g., 'openai/gpt-4')"""
        if provider.startswith("openai/"):
            return self.openai
        elif provider.startswith("anthropic/"):
            return self.anthropic
        elif provider.startswith("google/"):
            return self.google
        return None
```

**Why**: Domain entity, pure Python, no external dependencies ✅

---

**Phase 2: Port Interface Extension**

**Step 2.1**: Extend `OrchestratorPort.process_message()`
```python
# src/domain/ports/outbound/orchestrator_port.py
from src.domain.entities.api_key_set import ApiKeySet

class OrchestratorPort(ABC):
    @abstractmethod
    async def process_message(
        self,
        message: str,
        conversation_id: str,
        page_context: dict | None = None,
        api_keys: ApiKeySet | None = None,  # NEW
    ) -> AsyncIterator[StreamChunk]:
        """Process message with optional API keys (DEV_MODE)"""
```

**Step 2.2**: Update `FakeOrchestratorAdapter`
```python
# tests/unit/fakes/fake_orchestrator.py
async def process_message(
    self,
    message: str,
    conversation_id: str,
    page_context: dict | None = None,
    api_keys: ApiKeySet | None = None,  # Accept but ignore in fake
) -> AsyncIterator[StreamChunk]:
    yield StreamChunk.text("Fake response")
```

---

**Phase 3: Adapter Implementation**

**Step 3.1**: Store api_keys in `AdkOrchestratorAdapter`
```python
# src/adapters/outbound/adk/orchestrator_adapter.py
class AdkOrchestratorAdapter(OrchestratorPort):
    def __init__(
        self,
        model: str,
        dynamic_toolset: DynamicToolset,
        instruction: str = "...",
        enable_llm_logging: bool = True,
        api_keys: ApiKeySet | None = None,  # NEW
    ):
        self._model_name = model
        self._api_keys = api_keys
```

**Step 3.2**: Modify `_rebuild_agent()` to inject `api_key`
```python
async def _rebuild_agent(self) -> None:
    provider_key = None
    if self._api_keys:
        provider_key = self._api_keys.get_key_for_provider(self._model_name)

    # Create LiteLlm with api_key parameter (bypasses os.environ!)
    lite_llm_model = LiteLlm(
        model=self._model_name,
        api_key=provider_key,  # Direct injection (thread-safe!)
    ) if provider_key else LiteLlm(model=self._model_name)

    self._agent = LlmAgent(
        model=lite_llm_model,
        name="agenthub_agent",
        instruction=dynamic_instruction,
        tools=[self._dynamic_toolset],
        sub_agents=list(self._sub_agents.values()),
    )
```

**Step 3.3**: Update `process_message()` to rebuild on key change
```python
async def process_message(
    self,
    message: str,
    conversation_id: str,
    page_context: dict | None = None,
    api_keys: ApiKeySet | None = None,  # NEW
) -> AsyncIterator[StreamChunk]:
    # Rebuild agent if api_keys changed
    if api_keys != self._api_keys:
        self._api_keys = api_keys
        await self._rebuild_agent()

    # Continue with existing logic...
```

---

**Phase 4: HTTP Layer**

**Step 4.1**: Extend `ChatRequest` schema
```python
# src/adapters/inbound/http/schemas/chat.py
from src.domain.entities.api_key_set import ApiKeySet

class ChatRequest(BaseModel):
    conversation_id: str | None = None
    message: str = Field(..., min_length=1)
    page_context: PageContextSchema | None = None
    api_keys: dict[str, str] | None = None  # DEV_MODE only

    def to_api_key_set(self) -> ApiKeySet | None:
        if not self.api_keys:
            return None
        return ApiKeySet(
            openai=self.api_keys.get("openai"),
            anthropic=self.api_keys.get("anthropic"),
            google=self.api_keys.get("google"),
        )
```

**Step 4.2**: Update chat route with DEV_MODE validation
```python
# src/adapters/inbound/http/routes/chat.py
@router.post("/stream")
@inject
async def chat_stream(request: Request, body: ChatRequest, orchestrator: OrchestratorService):
    # DEV_MODE enforcement
    if body.api_keys:
        settings = Settings()
        if not settings.dev_mode:
            raise HTTPException(status_code=403, detail="api_keys field only allowed in DEV_MODE")

    return StreamingResponse(_generate_chat_stream(request, body, orchestrator), ...)
```

**Step 4.3**: Pass api_keys to orchestrator
```python
async def _generate_chat_stream(request, body, orchestrator):
    api_key_set = body.to_api_key_set()

    async for chunk in orchestrator.send_message(
        conversation_id=conversation_id,
        message=body.message,
        page_context=page_context_dict,
        api_keys=api_key_set,  # NEW
    ):
        yield f"data: {json.dumps(chunk.to_dict())}\n\n"
```

---

**Phase 5: Service Layer Passthrough**

**Step 5.1**: Update `OrchestratorService.send_message()`
```python
# src/domain/services/orchestrator_service.py
async def send_message(
    self,
    conversation_id: str,
    message: str,
    page_context: dict | None = None,
    api_keys: ApiKeySet | None = None,  # NEW
) -> AsyncIterator[StreamChunk]:
    async for chunk in self._conversation_service.send_message(
        conversation_id=conversation_id,
        message=message,
        page_context=page_context,
        api_keys=api_keys,  # Pass through
    ):
        yield chunk
```

**Step 5.2**: Update `ConversationService.send_message()`
```python
# src/domain/services/conversation_service.py
async def send_message(
    self,
    conversation_id: str,
    message: str,
    page_context: dict | None = None,
    api_keys: ApiKeySet | None = None,  # NEW
) -> AsyncIterator[StreamChunk]:
    async for chunk in self._orchestrator.process_message(
        message=message,
        conversation_id=conversation_id,
        page_context=page_context,
        api_keys=api_keys,  # Pass through
    ):
        yield chunk
```

---

**Phase 6: Frontend UI**

**Step 6.1**: Add API Key input section (HTML)
```html
<!-- tests/manual/playground/index.html -->
<div id="chat-tab" class="tab-pane active">
    <!-- NEW: Collapsible API Key Section -->
    <div class="api-key-section" data-testid="api-key-section">
        <details>
            <summary>⚙️ API Keys (Optional - DEV_MODE only)</summary>
            <div class="api-key-inputs">
                <input type="password" data-testid="api-key-openai" placeholder="OpenAI API Key (sk-...)" />
                <input type="password" data-testid="api-key-anthropic" placeholder="Anthropic API Key (sk-...)" />
                <input type="password" data-testid="api-key-google" placeholder="Google API Key" />
            </div>
        </details>
    </div>

    <div class="chat-panel">
        <!-- Existing chat UI -->
    </div>
</div>
```

**Step 6.2**: Update `api-client.js`
```javascript
// tests/manual/playground/js/api-client.js
export async function sendChatMessage(message, conversationId, apiKeys = null) {
    const body = { message, conversation_id: conversationId };

    // Include api_keys if provided
    if (apiKeys && Object.keys(apiKeys).length > 0) {
        body.api_keys = apiKeys;
    }

    const response = await fetch(`${BASE_URL}/api/chat/stream`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
    });

    return response.body;
}
```

**Step 6.3**: Update `main.js` to collect API keys
```javascript
// tests/manual/playground/js/main.js
export function initChatHandlers() {
    const sendBtn = document.querySelector("[data-testid='chat-send-btn']");

    sendBtn.addEventListener("click", async () => {
        const message = chatInput.value.trim();
        if (!message) return;

        // Collect non-empty API keys
        const apiKeys = {};
        const openaiKey = document.querySelector("[data-testid='api-key-openai']").value.trim();
        const anthropicKey = document.querySelector("[data-testid='api-key-anthropic']").value.trim();
        const googleKey = document.querySelector("[data-testid='api-key-google']").value.trim();

        if (openaiKey) apiKeys.openai = openaiKey;
        if (anthropicKey) apiKeys.anthropic = anthropicKey;
        if (googleKey) apiKeys.google = googleKey;

        // Send with API keys
        const stream = await sendChatMessage(message, null, apiKeys);
        const handler = new SseHandler(stream, ...);
        handler.connect();
    });
}
```

**Step 6.4**: Add CSS styling
```css
/* tests/manual/playground/css/styles.css */
.api-key-section {
    background: #f9f9f9;
    padding: 10px;
    margin-bottom: 15px;
    border-radius: 5px;
}

.api-key-section details summary {
    cursor: pointer;
    font-weight: bold;
}

.api-key-inputs {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 10px;
}

.api-key-inputs input {
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-family: monospace;
}
```

---

**Phase 7: Testing**

**Unit Tests**:
```python
# tests/unit/adapters/test_orchestrator_adapter.py
@pytest.mark.asyncio
async def test_api_key_injection_rebuilds_agent():
    api_keys = ApiKeySet(openai="sk-test-key-1")
    async for chunk in orchestrator.process_message(
        message="Hello", conversation_id="test", api_keys=api_keys
    ):
        pass
    assert orchestrator._api_keys == api_keys
```

**Integration Tests**:
```python
# tests/integration/adapters/test_chat_routes.py
@pytest.mark.asyncio
async def test_chat_with_api_keys_in_dev_mode(client, monkeypatch):
    monkeypatch.setenv("DEV_MODE", "true")
    response = await client.post("/api/chat/stream", json={
        "message": "Test",
        "api_keys": {"openai": "sk-test-key"}
    })
    assert response.status_code == 200

@pytest.mark.asyncio
async def test_chat_with_api_keys_in_production_rejected(client):
    response = await client.post("/api/chat/stream", json={
        "message": "Test",
        "api_keys": {"openai": "sk-test-key"}
    })
    assert response.status_code == 403
```

**E2E Tests**:
```python
# tests/e2e/test_playground_api_keys.py
@pytest.mark.e2e_playwright
async def test_playground_api_key_input(page):
    await page.goto("http://localhost:3000")
    await page.fill("[data-testid='api-key-openai']", "sk-test-key")
    await page.fill("[data-testid='chat-input']", "Hello")
    await page.click("[data-testid='chat-send-btn']")
    await page.wait_for_selector("[data-testid='sse-done']")
```

#### Critical Files

1. **`src/domain/entities/api_key_set.py`** (NEW) - Core abstraction
2. **`src/domain/ports/outbound/orchestrator_port.py`** - Add `api_keys` parameter
3. **`src/adapters/outbound/adk/orchestrator_adapter.py`** - Inject `api_key` into `LiteLlm()`
4. **`src/adapters/inbound/http/schemas/chat.py`** - Add `api_keys` field
5. **`src/adapters/inbound/http/routes/chat.py`** - DEV_MODE validation
6. **`src/domain/services/orchestrator_service.py`** - Passthrough
7. **`src/domain/services/conversation_service.py`** - Passthrough
8. **`tests/manual/playground/index.html`** - API key input UI
9. **`tests/manual/playground/js/main.js`** - Collect keys from inputs
10. **`tests/manual/playground/js/api-client.js`** - Send keys in request
11. **`tests/unit/fakes/fake_orchestrator.py`** - Accept `api_keys` parameter

---

## Security Checklist

| Item | Status | Validation |
|------|--------|------------|
| DEV_MODE enforcement | ✅ | `api_keys` rejected if `dev_mode=false` |
| CORS restriction | ✅ | localhost:3000 only in DEV_MODE |
| No localStorage | ✅ | Keys in memory only (form inputs) |
| Thread safety | ✅ | `api_key` parameter is request-scoped |
| API key masking | ⚠️ | TODO: Add logging filter |
| Container isolation | ✅ | Agent rebuilt per key change |

---

## Verification Plan

### Solution 1 (MCP Duplication)

```bash
# Step 1: Run individual tests (should pass)
pytest tests/e2e/test_playground.py::TestPlaygroundMcpManagement::test_mcp_server_registration_flow -v

# Step 2: Run all MCP tests together (should pass after fix)
pytest tests/e2e/test_playground.py::TestPlaygroundMcpManagement -v

# Step 3: Verify cache invalidation
pytest tests/integration/adapters/test_test_utils.py::TestResetDataCacheInvalidation -v

# Step 4: Full E2E suite
pytest tests/e2e/test_playground.py -m e2e_playwright -v
```

### Solution 2 (API Key Management)

```powershell
# Manual Testing
$env:DEV_MODE="true"; uvicorn src.main:app --host localhost --port 8000
cd tests/manual/playground; python -m http.server 3000
# Open http://localhost:3000
# Expand "API Keys" section, enter OpenAI key, send message

# Automated Testing
pytest tests/unit/adapters/test_orchestrator_adapter.py -k api_key -v
pytest tests/integration/adapters/test_chat_routes.py -k api_key -v
pytest tests/e2e/test_playground_api_keys.py -v
```

---

## Implementation Order

1. **Solution 1 (MCP Duplication)** - Critical for test reliability
   - Blocking E2E test development
   - Estimated: 2-3 hours

2. **Solution 2 (API Key Management)** - User-facing feature
   - Enables flexible testing without .env changes
   - Estimated: 3-4 hours

**Total Estimated Time**: 5-7 hours

---

## References

### Investigation Reports
- Explore Agent ab622c9: MCP duplicate checking & state isolation
- Explore Agent a4a21dd: API key flow & DEV_MODE validation
- Plan Agent a123556: MCP duplication solution options
- Plan Agent ad72be7: API key management design

### External Documentation
- [Python os.environ Thread Safety Issues](https://bugs.python.org/issue39375)
- [LiteLLM API Key Settings](https://docs.litellm.ai/docs/set_keys)
- [Google ADK LiteLLM Integration](https://docs.litellm.ai/docs/tutorials/google_adk)

### Project Documents
- [CLAUDE.md](C:\Users\sungb\Documents\GitHub\AgentHub\CLAUDE.md) - TDD & Hexagonal Architecture principles
- [tests/README.md](C:\Users\sungb\Documents\GitHub\AgentHub\tests\README.md) - Test strategy
- [docs/project/planning/active/08_playground/05.3_ui_element_issues.md](C:\Users\sungb\Documents\GitHub\AgentHub\docs\project\planning\active\08_playground\05.3_ui_element_issues.md) - Investigation report

---

**Plan Status**: Ready for Implementation ✅
**Architectural Compliance**: Hexagonal ✅ | TDD ✅ | DEV_MODE ✅ | Security ✅
